# 12.1 
内核用page来表示一个物理页
```
struct page
{
    unsigned long flags;
    atomic_t _count;
    atomic_t _mapcount;
    unsigned long private;
    struct address_space *mapping;
    pgoff_t index;
    struct list_head lru;
    void* virtual;
}
```
# 12.2 区
x86_32存在着高端内存
```
高端内存 3GB + 896MB之上的物理内存
```
x86_64没有高端内存

# 12.3 获得页
在低端内存上分配2^order个连续的物理页，返回第一个页的page结构体
```
struct page* alloc_pages(gfp_t gfp_mask, unsigned int order)

struct page* alloc_page(gfp_t gfp_mask) // 只需要一页
```
或者直接用
```
unsigned long __get_free_pages(gfp_t gfp_mask, unsigned int order)

unsigned long __get_free_page(gfp_t gfp_mask) // 一页
```
直接返回第一个页的虚拟地址

释放页
```
void __free_pages(struct page* page, unsigned int order)
void free_pages(unsigned long addr, unsigned int order);
void free_page(unsigned long addr);
```

# 12.4 kmalloc()
```
void* kmalloc(size_t size, gfp_t flags)
```
获取大小为size的一块内核内存

## 12.4.1 gfp_mask标志
分配的虚拟地址连续，物理地址也连续
```
ptr = kmalloc(size, __GFP_WAIT | __GFP_IO | __GFP_FS);
```
说明页分配器（最终调用alloc_pages()函数）在分配时可以阻塞，可以执行I/O,在必要的时候可以执行文件系统操作

## 12.4.2 kfree()
```
void kfree(const void* ptr)
```

# 12.5 vmalloc()
分配的虚拟地址连续，物理地址不连续
**当模块被动态插入到内核中时，就把模块装载到由vmalloc分配的内存上**
```
void* vmalloc(unsigned long size);
void vfree(const void* addr);
```

# 12.6 slab层
空闲链表包含分配好的数据结构块

### kmem_getpages(struct kmemcache* cachep, gfp_t flags)：
```
static inline void * kmem_getpages(struct kmem_cache* cachep, gfp_t flags)
{
    void* addr;
    flags |= cachep->gfpflags;
    addr = (void*)__get_free_pages(flags, cachep->gfporder);
    return addr;
}
```

进程调用fork()时，一定会创建一个新的task_struct
```
struct task_struct* tsk;
tsk = kmem_cache_alloc(task_struct_cachep, GFP_KERNEL);
if (!tsk)
    return NULL;
```
进程执行完后，如果没有子进程在wait,进程描述符将会被释放
```
kmem_cache_free(task_struct_cachep, tsk);
```
